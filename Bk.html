<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
  <title>HTML5 Breakout – Levels + Highscore + Multiball + Orange</title>
  <style>
    html,body{margin:0;background:#111}
    #wrap{display:flex;flex-direction:column;align-items:center;padding:10px}
    canvas{background:#000;border:1px solid #333;max-width:100vw;height:auto;touch-action:none}
    button{margin-top:8px;background:#222;color:#ddd;border:1px solid #444;padding:6px 10px;cursor:pointer}
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="game" width="480" height="640"></canvas>
  <button id="restartBtn" style="display:none">Restart</button>
</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha:false });
  const restartBtn = document.getElementById('restartBtn');

  // Persistent high score
  const HS_KEY = 'breakout_highscore_v3';
  let highScore = Number(localStorage.getItem(HS_KEY) || 0);

  // Dimensions / layout
  const W = canvas.width, H = canvas.height;
  const HUD_H = 26;            // reserved strip for HUD inside canvas
  const WALL_PAD_X = 24;       // side padding for bricks
  const TOP_PAD = HUD_H + 18;  // top padding for bricks under HUD
  const SAFE_BRICK_HEIGHT = Math.floor(H * 0.5); // max brick band height to avoid clipping last row

  // Game state
  let paddleBaseW = 84;
  let paddle = { w: paddleBaseW, h: 12, x: (W-paddleBaseW)/2, y: H - 40, speed: 7 };
  let balls = []; // multiple balls support
  let rows = 7, cols = 8, gap = 6, brickW = 40, brickH = 22;
  let bricks = [];
  let leftPressed = false, rightPressed = false;
  let score = 0, lives = 3, level = 1, running = false, gameOver = false;
  let powerups = []; // falling powerups
  let levelBannerTimer = 0;
  let overlayMsg = 'Press Space / Tap to start';

  // Brick types
  const BRICK_TYPES = {
    YELLOW: { hp:1, color:'#ffd54a', breakable:true, score:10 },
    BLUE:   { hp:2, color:'#4aa3ff', breakable:true, score:20 },
    GREEN:  { hp:3, color:'#39d17d', breakable:true, score:30 },
    RED:    { hp:Infinity, color:'#ff3b3b', breakable:false, score:0 },
  };

  // Powerups
  // widen | slow | life | multiball | orange
  const PU_COLORS = {
    widen:'#8ab4f8', slow:'#fbbc04', life:'#34a853',
    multiball:'#b388ff', orange:'#ff8a00'
  };
  const PU_SIZE = 14;
  const PU_SPEED = 2.2;
  const PU_CHANCE = 0.22;

  // Balls
  function newBall(serveUp = true, fromX = W/2, fromY = paddle.y - 20) {
    const angle = (Math.random()*0.6 + 0.2) * Math.PI; // 36°–144°
    const speed = 5 + level*0.35;
    return {
      x: fromX, y: fromY, r: 7,
      vx: Math.cos(angle) * speed * (Math.random()<0.5?-1:1),
      vy: (serveUp ? -1 : 1) * Math.abs(Math.sin(angle) * speed),
      slowTimer: 0,
      orangeTimer: 0 // when >0, this ball destroys any brick in one hit
    };
  }

  // Random helpers
  function randPickBrickType() {
    const r = Math.random();
    const redCut = 0.10 + Math.random()*0.05;
    if (r < redCut) return 'RED';
    if (r < redCut + 0.25) return 'GREEN';
    if (r < redCut + 0.55) return 'BLUE';
    return 'YELLOW';
  }

  function ensureBreakablesPresent(layout) {
    if (!layout.some(b => b.breakable && b.hp > 0)) {
      for (let i = 0; i < layout.length; i += Math.ceil(layout.length / 6)) {
        const s = BRICK_TYPES.YELLOW;
        Object.assign(layout[i], { kind:'YELLOW', hp:s.hp, breakable:s.breakable, color:s.color, score:s.score });
      }
    }
  }

  function randomizeGridForLevel() {
    // Compute cols/rows that fit inside SAFE_BRICK_HEIGHT band
    // Start from a target and clamp down until it fits.
    cols = Math.min(10, 7 + (level % 3) + (Math.random() < 0.4 ? 1 : 0));
    gap = 6;
    brickW = (W - 2*WALL_PAD_X - (cols-1)*gap) / cols;

    // Try rows based on level, then clamp so total height fits the safe band
    let targetRows = Math.min(12, 6 + Math.floor(level/2) + (Math.random() < 0.5 ? 0 : 1));
    brickH = 22;
    while (targetRows > 1) {
      const totalH = targetRows*brickH + (targetRows-1)*gap;
      if (totalH <= SAFE_BRICK_HEIGHT) break;
      targetRows--;
    }
    rows = targetRows;
  }

  function makeBricks() {
    randomizeGridForLevel();
    const layout = [];
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        let kind = randPickBrickType();
        if (r % 3 === 2 && Math.random() < 0.55) {
          kind = ['YELLOW','BLUE','GREEN'][Math.floor(Math.random()*3)];
        }
        const spec = BRICK_TYPES[kind];
        layout.push({
          x: WALL_PAD_X + c*(brickW+gap),
          y: TOP_PAD + r*(brickH+gap),
          w: brickW, h: brickH,
          hp: spec.hp,
          color: spec.color,
          breakable: spec.breakable,
          score: spec.score,
          kind
        });
      }
    }
    ensureBreakablesPresent(layout);
    bricks = layout;
  }

  function resetAll() {
    score = 0; lives = 3; level = 1;
    paddle.w = paddleBaseW; paddle.x = (W-paddle.w)/2;
    powerups = [];
    makeBricks();
    balls = [newBall(true)];
    running = false; gameOver = false;
    levelBannerTimer = 90;
    overlayMsg = 'Press Space / Tap to start';
    restartBtn.style.display = 'none';
  }

  function saveHighScore() {
    if (score > highScore) {
      highScore = score;
      localStorage.setItem(HS_KEY, String(highScore));
    }
  }

  // Input
  addEventListener('keydown', e => {
    if (e.key === 'ArrowLeft') leftPressed = true;
    if (e.key === 'ArrowRight') rightPressed = true;
    if (e.key === ' ') { if (!gameOver) running = true; }
  });
  addEventListener('keyup', e => {
    if (e.key === 'ArrowLeft') leftPressed = false;
    if (e.key === 'ArrowRight') rightPressed = false;
  });

  function setPaddleFromClientX(clientX) {
    const rect = canvas.getBoundingClientRect();
    const x = (clientX - rect.left) * (canvas.width / rect.width);
    paddle.x = Math.min(W - paddle.w, Math.max(0, x - paddle.w/2));
  }
  canvas.addEventListener('pointerdown', e => { setPaddleFromClientX(e.clientX); if (!gameOver) running = true; });
  canvas.addEventListener('pointermove', e => { if (e.pressure || e.buttons) setPaddleFromClientX(e.clientX); });

  restartBtn.onclick = () => resetAll();

  // Collisions
  function aabbCircleHit(b, cx, cy, r) {
    const nx = Math.max(b.x, Math.min(cx, b.x + b.w));
    const ny = Math.max(b.y, Math.min(cy, b.y + b.h));
    const dx = cx - nx, dy = cy - ny;
    return dx*dx + dy*dy <= r*r;
  }

  // Powerups
  function spawnPowerup(x, y) {
    const roll = Math.random();
    let type;
    if (roll < 0.22) type = 'widen';
    else if (roll < 0.44) type = 'slow';
    else if (roll < 0.62) type = 'life';
    else if (roll < 0.82) type = 'multiball';
    else type = 'orange';
    powerups.push({ x: x - PU_SIZE/2, y: y, type });
  }

  function applyPowerup(p) {
    if (p.type === 'widen') {
      paddle.w = Math.min(paddle.w + 24, 164);
    } else if (p.type === 'slow') {
      for (const b of balls) b.slowTimer = Math.max(b.slowTimer, 600);
    } else if (p.type === 'life') {
      lives += 1;
    } else if (p.type === 'multiball') {
      // duplicate a random existing ball with mirrored velocity
      if (balls.length < 5) {
        const src = balls[Math.floor(Math.random()*balls.length)];
        const clone = { ...src, vx: -src.vx, vy: src.vy, orangeTimer: 0, slowTimer: src.slowTimer };
        balls.push(clone);
      }
    } else if (p.type === 'orange') {
      // empower all balls briefly
      for (const b of balls) b.orangeTimer = Math.max(b.orangeTimer, 540); // ~9s
    }
  }

  // Level control
  function nextLevel() {
    level++;
    saveHighScore();
    powerups = [];
    paddle.w = Math.max(64, paddle.w - 4);
    makeBricks();
    balls = [newBall(true)];
    running = false;
    levelBannerTimer = 60;
    overlayMsg = '';
    setTimeout(() => { if (!gameOver) running = true; }, 900);
  }

  // Update
  function update() {
    if (levelBannerTimer > 0) levelBannerTimer--;

    if (!running || gameOver) return;

    // Paddle
    if (leftPressed) paddle.x -= paddle.speed;
    if (rightPressed) paddle.x += paddle.speed;
    paddle.x = Math.max(0, Math.min(W - paddle.w, paddle.x));

    // Balls
    for (let bi = balls.length - 1; bi >= 0; bi--) {
      const ball = balls[bi];

      if (ball.slowTimer > 0) ball.slowTimer--;
      if (ball.orangeTimer > 0) ball.orangeTimer--;

      const speedFactor = ball.slowTimer > 0 ? 0.6 : 1;
      ball.x += ball.vx * speedFactor;
      ball.y += ball.vy * speedFactor;

      // Walls
      if (ball.x - ball.r < 0 && ball.vx < 0) { ball.x = ball.r; ball.vx *= -1; }
      if (ball.x + ball.r > W && ball.vx > 0) { ball.x = W - ball.r; ball.vx *= -1; }
      if (ball.y - ball.r < HUD_H && ball.vy < 0) { ball.y = HUD_H + ball.r; ball.vy *= -1; }

      // Paddle
      if (ball.y + ball.r >= paddle.y &&
          ball.x > paddle.x && ball.x < paddle.x + paddle.w &&
          ball.vy > 0) {
        ball.y = paddle.y - ball.r;
        const hit = (ball.x - (paddle.x + paddle.w/2)) / (paddle.w/2);
        const speed = Math.hypot(ball.vx, ball.vy);
        const angle = (-Math.PI/3) * hit;
        ball.vx = speed * Math.sin(angle);
        ball.vy = -Math.abs(Math.sqrt(Math.max(0, speed*speed - ball.vx*ball.vx)));
      }

      // Bricks
      for (const b of bricks) {
        const alive = b.breakable ? b.hp > 0 : true;
        if (!alive) continue;
        if (!aabbCircleHit(b, ball.x, ball.y, ball.r)) continue;

        // side reflect
        const prevX = ball.x - ball.vx * speedFactor, prevY = ball.y - ball.vy * speedFactor;
        const wasLeft = prevX <= b.x, wasRight = prevX >= b.x + b.w;
        const wasAbove = prevY <= b.y, wasBelow = prevY >= b.y + b.h;
        if ((wasLeft && ball.vx > 0) || (wasRight && ball.vx < 0)) ball.vx *= -1;
        if ((wasAbove && ball.vy > 0) || (wasBelow && ball.vy < 0)) ball.vy *= -1;

        // damage logic
        if (ball.orangeTimer > 0) {
          // orange ball breaks ANY brick in one hit
          if (b.breakable || (!b.breakable && b.kind === 'RED')) {
            b.hp = 0; b.breakable = true; // mark destroyed
            score += 40; // orange hits give a bit extra
            if (Math.random() < PU_CHANCE) spawnPowerup(ball.x, b.y + b.h/2);
            saveHighScore();
          }
        } else {
          if (b.breakable) {
            b.hp -= 1;
            if (b.hp <= 0) {
              score += b.score;
              if (Math.random() < PU_CHANCE) spawnPowerup(ball.x, b.y + b.h/2);
              saveHighScore();
            }
          }
        }
        break;
      }

      // Fell out
      if (ball.y - ball.r > H) {
        balls.splice(bi, 1);
      }
    }

    // Lose life when no balls remain
    if (balls.length === 0) {
      lives--;
      if (lives < 0) {
        running = false; gameOver = true;
        overlayMsg = 'Game Over';
        restartBtn.style.display = 'inline-block';
        saveHighScore();
      } else {
        balls = [newBall(true)];
        running = false;
        overlayMsg = 'Life lost. Press Space / Tap to continue';
      }
    }

    // Powerups
    for (let i = powerups.length - 1; i >= 0; i--) {
      const p = powerups[i];
      p.y += PU_SPEED;
      if (p.y + PU_SIZE >= paddle.y &&
          p.x + PU_SIZE >= paddle.x &&
          p.x <= paddle.x + paddle.w) {
        applyPowerup(p);
        powerups.splice(i,1);
        continue;
      }
      if (p.y > H + 20) powerups.splice(i,1);
    }

    // Next level if all breakable bricks cleared (ignore intact reds)
    const remaining = bricks.some(b => (b.breakable && b.hp > 0));
    if (!remaining) nextLevel();
  }

  // Draw HUD inside canvas
  function drawHUD() {
    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, W, HUD_H);
    ctx.fillStyle = '#ddd';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    ctx.fillText(`Score: ${score}`, 8, HUD_H/2);
    ctx.fillText(`High: ${highScore}`, 92, HUD_H/2);
    ctx.fillText(`Lives: ${lives}`, 176, HUD_H/2);
    ctx.fillText(`Level: ${level}`, 252, HUD_H/2);
  }

  // Draw everything
  function draw() {
    // Clear
    ctx.clearRect(0,0,W,H);

    // HUD
    drawHUD();

    // Bricks
    for (const b of bricks) {
      if (b.breakable && b.hp <= 0) continue;
      ctx.fillStyle = b.color;
      ctx.fillRect(b.x, b.y, b.w, b.h);
      ctx.strokeStyle = '#111'; ctx.lineWidth = 1;
      ctx.strokeRect(b.x+0.5, b.y+0.5, b.w-1, b.h-1);
      if (b.breakable && b.hp !== Infinity) {
        ctx.fillStyle = '#000';
        for (let i = 0; i < Math.min(3, b.hp); i++) {
          ctx.fillRect(b.x + 4 + i*6, b.y + 4, 4, 4);
        }
      }
    }

    // Paddle
    ctx.fillStyle = '#0ae';
    ctx.fillRect(paddle.x, paddle.y, paddle.w, paddle.h);

    // Balls
    for (const ball of balls) {
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
      if (ball.orangeTimer > 0) {
        ctx.fillStyle = '#ff8a00'; // orange strong ball
      } else {
        ctx.fillStyle = '#fff';
      }
      ctx.fill();
    }

    // Powerups
    for (const p of powerups) {
      ctx.fillStyle = PU_COLORS[p.type];
      ctx.fillRect(p.x, p.y, PU_SIZE, PU_SIZE);
      ctx.fillStyle = '#000';
      ctx.font = '10px system-ui';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const label =
        p.type === 'widen' ? 'W' :
        p.type === 'slow' ? 'S' :
        p.type === 'life' ? '+' :
        p.type === 'multiball' ? 'MB' : 'O';
      ctx.fillText(label, p.x + PU_SIZE/2, p.y + PU_SIZE/2 + 0.5);
    }

    // Border
    ctx.strokeStyle = '#333';
    ctx.strokeRect(0.5, 0.5, W-1, H-1);

    // Level banner / overlay message
    if (levelBannerTimer > 0) {
      ctx.fillStyle = 'rgba(255,255,255,0.08)';
      ctx.fillRect(0, 0, W, H);
      ctx.fillStyle = '#ddd';
      ctx.font = 'bold 24px system-ui';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(`LEVEL ${level}`, W/2, H/2);
    } else if (overlayMsg) {
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.fillRect(0, H - 36, W, 36);
      ctx.fillStyle = '#ddd';
      ctx.font = '12px system-ui';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(overlayMsg, W/2, H - 18);
    }
  }

  function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
  }

  // Init
  makeBricks();
  balls = [newBall(true)];
  overlayMsg = 'Press Space / Tap to start';
  levelBannerTimer = 90;
  loop();
})();
</script>
</body>
</html>
